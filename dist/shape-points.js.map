{"version":3,"file":"shape-points.js","sources":["../arc.js","../bezierCurveTo.js","../node_modules/fit-curve/lib/fit-curve.js","../bezierCurveThrough.js","../circle.js","../ellipse.js","../line.js","../quadraticCurveTo.js","../rect.js","../roundedRect.js"],"sourcesContent":["/**\n * calculate points for arc\n * @module shape-points/arc\n * @param {number} x\n * @param {number} y\n * @param {number} start angle (radians)\n * @param {number} end angle (radians)\n * @param {number} radius\n * @param {number} [pointsInArc=5]\n * @returns {array} [x1, y1, x2, y2, ... xn, yn]\n */\nexport function arc(x, y, start, end, radius, pointsInArc)\n{\n    pointsInArc = pointsInArc || 5\n    const points = []\n    let angle = start\n    const interval = (end - start) / pointsInArc\n    for (let count = 0; count < pointsInArc; count++)\n    {\n        points.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle))\n        angle += interval\n    }\n    return points\n}\n\n","/**\n * Calculate points for a bezier curve with a starting point and two control points\n * from https://stackoverflow.com/a/15399173/1955997\n * @module shape-points/bezierCurveTo\n * @param {number} x1 - starting point (usually a moveTo)\n * @param {number} y1 - starting point\n * @param {number} cp1x - first control point\n * @param {number} cp1y - first control point\n * @param {number} cp2x - second control point\n * @param {number} cp2y - second control point\n * @param {number} x2 - ending point\n * @param {number} y2 - ending point\n * @param {number} [pointsInArc=5]\n * @returns {array} [x1, y1, x2, y2, ... xn, yn]\n */\nexport function bezierCurveTo(x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2, pointsInArc)\n{\n    pointsInArc = pointsInArc || 5\n    const points = []\n    const interval = 1 / pointsInArc\n    for (let t = 0; t <= 1; t += interval)\n    {\n        const B0_t = Math.pow(1 - t, 3),\n            B1_t = 3 * t * Math.pow(1 - t, 2),\n            B2_t = 3 * Math.pow(t, 2) * (1 - t),\n            B3_t = Math.pow(t, 3)\n\n        points.push(\n            (B0_t * x1) + (B1_t * cp1x) + (B2_t * cp2x) + (B3_t * x2),\n            (B0_t * y1) + (B1_t * cp1y) + (B2_t * cp2y) + (B3_t * y2)\n        )\n    }\n    return points\n}\n","(function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define(['module'], factory);\n    } else if (typeof exports !== \"undefined\") {\n        factory(module);\n    } else {\n        var mod = {\n            exports: {}\n        };\n        factory(mod);\n        global.fitCurve = mod.exports;\n    }\n})(this, function (module) {\n    'use strict';\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    // ==ClosureCompiler==\n    // @output_file_name fit-curve.min.js\n    // @compilation_level SIMPLE_OPTIMIZATIONS\n    // ==/ClosureCompiler==\n\n    /**\r\n     *  @preserve  JavaScript implementation of\r\n     *  Algorithm for Automatically Fitting Digitized Curves\r\n     *  by Philip J. Schneider\r\n     *  \"Graphics Gems\", Academic Press, 1990\r\n     *\r\n     *  The MIT License (MIT)\r\n     *\r\n     *  https://github.com/soswow/fit-curves\r\n     */\n\n    /**\r\n     * Fit one or more Bezier curves to a set of points.\r\n     *\r\n     * @param {Array<Array<Number>>} points - Array of digitized points, e.g. [[5,5],[5,50],[110,140],[210,160],[320,110]]\r\n     * @param {Number} maxError - Tolerance, squared error between points and fitted curve\r\n     * @returns {Array<Array<Array<Number>>>} Array of Bezier curves, where each element is [first-point, control-point-1, control-point-2, second-point] and points are [x, y]\r\n     */\n    function fitCurve(points, maxError, progressCallback) {\n        if (!Array.isArray(points)) {\n            throw new TypeError(\"First argument should be an array\");\n        }\n        points.forEach(function (point) {\n            if (!Array.isArray(point) || point.length !== 2 || typeof point[0] !== 'number' || typeof point[1] !== 'number') {\n                throw Error(\"Each point should be an array of two numbers\");\n            }\n        });\n        // Remove duplicate points\n        points = points.filter(function (point, i) {\n            return i === 0 || !(point[0] === points[i - 1][0] && point[1] === points[i - 1][1]);\n        });\n\n        if (points.length < 2) {\n            return [];\n        }\n\n        var len = points.length;\n        var leftTangent = createTangent(points[1], points[0]);\n        var rightTangent = createTangent(points[len - 2], points[len - 1]);\n\n        return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);\n    }\n\n    /**\r\n     * Fit a Bezier curve to a (sub)set of digitized points.\r\n     * Your code should not call this function directly. Use {@link fitCurve} instead.\r\n     *\r\n     * @param {Array<Array<Number>>} points - Array of digitized points, e.g. [[5,5],[5,50],[110,140],[210,160],[320,110]]\r\n     * @param {Array<Number>} leftTangent - Unit tangent vector at start point\r\n     * @param {Array<Number>} rightTangent - Unit tangent vector at end point\r\n     * @param {Number} error - Tolerance, squared error between points and fitted curve\r\n     * @returns {Array<Array<Array<Number>>>} Array of Bezier curves, where each element is [first-point, control-point-1, control-point-2, second-point] and points are [x, y]\r\n     */\n    function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {\n        var MaxIterations = 20; //Max times to try iterating (to find an acceptable curve)\n\n        var bezCurve, //Control points of fitted Bezier curve\n        u, //Parameter values for point\n        uPrime, //Improved parameter values\n        maxError, prevErr, //Maximum fitting error\n        splitPoint, prevSplit, //Point to split point set at if we need more than one curve\n        centerVector, toCenterTangent, fromCenterTangent, //Unit tangent vector(s) at splitPoint\n        beziers, //Array of fitted Bezier curves if we need more than one curve\n        dist, i;\n\n        //console.log('fitCubic, ', points.length);\n\n        //Use heuristic if region only has two points in it\n        if (points.length === 2) {\n            dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3.0;\n            bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist)), points[1]];\n            return [bezCurve];\n        }\n\n        //Parameterize points, and attempt to fit curve\n        u = chordLengthParameterize(points);\n\n        var _generateAndReport = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);\n\n        bezCurve = _generateAndReport[0];\n        maxError = _generateAndReport[1];\n        splitPoint = _generateAndReport[2];\n\n\n        if (maxError < error) {\n            return [bezCurve];\n        }\n        //If error not too large, try some reparameterization and iteration\n        if (maxError < error * error) {\n\n            uPrime = u;\n            prevErr = maxError;\n            prevSplit = splitPoint;\n\n            for (i = 0; i < MaxIterations; i++) {\n\n                uPrime = reparameterize(bezCurve, points, uPrime);\n\n                var _generateAndReport2 = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);\n\n                bezCurve = _generateAndReport2[0];\n                maxError = _generateAndReport2[1];\n                splitPoint = _generateAndReport2[2];\n\n\n                if (maxError < error) {\n                    return [bezCurve];\n                }\n                //If the development of the fitted curve grinds to a halt,\n                //we abort this attempt (and try a shorter curve):\n                else if (splitPoint === prevSplit) {\n                        var errChange = maxError / prevErr;\n                        if (errChange > .9999 && errChange < 1.0001) {\n                            break;\n                        }\n                    }\n\n                prevErr = maxError;\n                prevSplit = splitPoint;\n            }\n        }\n\n        //Fitting failed -- split at max error point and fit recursively\n        beziers = [];\n\n        //To create a smooth transition from one curve segment to the next,\n        //we calculate the tangent of the points directly before and after the center,\n        //and use that same tangent both to and from the center point.\n        centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);\n        //However, should those two points be equal, the normal tangent calculation will fail.\n        //Instead, we calculate the tangent from that \"double-point\" to the center point, and rotate 90deg.\n        if (centerVector[0] === 0 && centerVector[1] === 0) {\n            //toCenterTangent = createTangent(points[splitPoint - 1], points[splitPoint]);\n            //fromCenterTangent = createTangent(points[splitPoint + 1], points[splitPoint]);\n\n            //[x,y] -> [-y,x]: http://stackoverflow.com/a/4780141/1869660\n            centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]).reverse();\n            centerVector[0] = -centerVector[0];\n        }\n        toCenterTangent = maths.normalize(centerVector);\n        //To and from need to point in opposite directions:\n        fromCenterTangent = maths.mulItems(toCenterTangent, -1);\n\n        /*\r\n        Note: An alternative to this \"divide and conquer\" recursion could be to always\r\n              let new curve segments start by trying to go all the way to the end,\r\n              instead of only to the end of the current subdivided polyline.\r\n              That might let many segments fit a few points more, reducing the number of total segments.\r\n                However, a few tests have shown that the segment reduction is insignificant\r\n              (240 pts, 100 err: 25 curves vs 27 curves. 140 pts, 100 err: 17 curves on both),\r\n              and the results take twice as many steps and milliseconds to finish,\r\n              without looking any better than what we already have.\r\n        */\n        beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));\n        beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));\n        return beziers;\n    };\n\n    function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {\n        var bezCurve, maxError, splitPoint;\n\n        bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);\n        //Find max deviation of points to fitted curve.\n        //Here we always use the original parameters (from chordLengthParameterize()),\n        //because we need to compare the current curve to the actual source polyline,\n        //and not the currently iterated parameters which reparameterize() & generateBezier() use,\n        //as those have probably drifted far away and may no longer be in ascending order.\n\n        var _computeMaxError = computeMaxError(points, bezCurve, paramsOrig);\n\n        maxError = _computeMaxError[0];\n        splitPoint = _computeMaxError[1];\n\n\n        if (progressCallback) {\n            progressCallback({\n                bez: bezCurve,\n                points: points,\n                params: paramsOrig,\n                maxErr: maxError,\n                maxPoint: splitPoint\n            });\n        }\n\n        return [bezCurve, maxError, splitPoint];\n    }\n\n    /**\r\n     * Use least-squares method to find Bezier control points for region.\r\n     *\r\n     * @param {Array<Array<Number>>} points - Array of digitized points\r\n     * @param {Array<Number>} parameters - Parameter values for region\r\n     * @param {Array<Number>} leftTangent - Unit tangent vector at start point\r\n     * @param {Array<Number>} rightTangent - Unit tangent vector at end point\r\n     * @returns {Array<Array<Number>>} Approximated Bezier curve: [first-point, control-point-1, control-point-2, second-point] where points are [x, y]\r\n     */\n    function generateBezier(points, parameters, leftTangent, rightTangent) {\n        var bezCurve,\n            //Bezier curve ctl pts\n        A,\n            a,\n            //Precomputed rhs for eqn\n        C,\n            X,\n            //Matrices C & X\n        det_C0_C1,\n            det_C0_X,\n            det_X_C1,\n            //Determinants of matrices\n        alpha_l,\n            alpha_r,\n            //Alpha values, left and right\n\n        epsilon,\n            segLength,\n            i,\n            len,\n            tmp,\n            u,\n            ux,\n            firstPoint = points[0],\n            lastPoint = points[points.length - 1];\n\n        bezCurve = [firstPoint, null, null, lastPoint];\n        //console.log('gb', parameters.length);\n\n        //Compute the A's\n        A = maths.zeros_Xx2x2(parameters.length);\n        for (i = 0, len = parameters.length; i < len; i++) {\n            u = parameters[i];\n            ux = 1 - u;\n            a = A[i];\n\n            a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));\n            a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));\n        }\n\n        //Create the C and X matrices\n        C = [[0, 0], [0, 0]];\n        X = [0, 0];\n        for (i = 0, len = points.length; i < len; i++) {\n            u = parameters[i];\n            a = A[i];\n\n            C[0][0] += maths.dot(a[0], a[0]);\n            C[0][1] += maths.dot(a[0], a[1]);\n            C[1][0] += maths.dot(a[0], a[1]);\n            C[1][1] += maths.dot(a[1], a[1]);\n\n            tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));\n\n            X[0] += maths.dot(a[0], tmp);\n            X[1] += maths.dot(a[1], tmp);\n        }\n\n        //Compute the determinants of C and X\n        det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];\n        det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];\n        det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];\n\n        //Finally, derive alpha values\n        alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;\n        alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;\n\n        //If alpha negative, use the Wu/Barsky heuristic (see text).\n        //If alpha is 0, you get coincident control points that lead to\n        //divide by zero in any subsequent NewtonRaphsonRootFind() call.\n        segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));\n        epsilon = 1.0e-6 * segLength;\n        if (alpha_l < epsilon || alpha_r < epsilon) {\n            //Fall back on standard (probably inaccurate) formula, and subdivide further if needed.\n            bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3.0));\n            bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3.0));\n        } else {\n            //First and last control points of the Bezier curve are\n            //positioned exactly at the first and last data points\n            //Control points 1 and 2 are positioned an alpha distance out\n            //on the tangent vectors, left and right, respectively\n            bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));\n            bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));\n        }\n\n        return bezCurve;\n    };\n\n    /**\r\n     * Given set of points and their parameterization, try to find a better parameterization.\r\n     *\r\n     * @param {Array<Array<Number>>} bezier - Current fitted curve\r\n     * @param {Array<Array<Number>>} points - Array of digitized points\r\n     * @param {Array<Number>} parameters - Current parameter values\r\n     * @returns {Array<Number>} New parameter values\r\n     */\n    function reparameterize(bezier, points, parameters) {\n        /*\r\n        var j, len, point, results, u;\r\n        results = [];\r\n        for (j = 0, len = points.length; j < len; j++) {\r\n            point = points[j], u = parameters[j];\r\n              results.push(newtonRaphsonRootFind(bezier, point, u));\r\n        }\r\n        return results;\r\n        //*/\n        return parameters.map(function (p, i) {\n            return newtonRaphsonRootFind(bezier, points[i], p);\n        });\n    };\n\n    /**\r\n     * Use Newton-Raphson iteration to find better root.\r\n     *\r\n     * @param {Array<Array<Number>>} bez - Current fitted curve\r\n     * @param {Array<Number>} point - Digitized point\r\n     * @param {Number} u - Parameter value for \"P\"\r\n     * @returns {Number} New u\r\n     */\n    function newtonRaphsonRootFind(bez, point, u) {\n        /*\r\n            Newton's root finding algorithm calculates f(x)=0 by reiterating\r\n            x_n+1 = x_n - f(x_n)/f'(x_n)\r\n            We are trying to find curve parameter u for some point p that minimizes\r\n            the distance from that point to the curve. Distance point to curve is d=q(u)-p.\r\n            At minimum distance the point is perpendicular to the curve.\r\n            We are solving\r\n            f = q(u)-p * q'(u) = 0\r\n            with\r\n            f' = q'(u) * q'(u) + q(u)-p * q''(u)\r\n            gives\r\n            u_n+1 = u_n - |q(u_n)-p * q'(u_n)| / |q'(u_n)**2 + q(u_n)-p * q''(u_n)|\r\n        */\n\n        var d = maths.subtract(bezier.q(bez, u), point),\n            qprime = bezier.qprime(bez, u),\n            numerator = /*sum(*/maths.mulMatrix(d, qprime) /*)*/\n        ,\n            denominator = maths.sum(maths.addItems(maths.squareItems(qprime), maths.mulMatrix(d, bezier.qprimeprime(bez, u))));\n\n        if (denominator === 0) {\n            return u;\n        } else {\n            return u - numerator / denominator;\n        }\n    };\n\n    /**\r\n     * Assign parameter values to digitized points using relative distances between points.\r\n     *\r\n     * @param {Array<Array<Number>>} points - Array of digitized points\r\n     * @returns {Array<Number>} Parameter values\r\n     */\n    function chordLengthParameterize(points) {\n        var u = [],\n            currU,\n            prevU,\n            prevP;\n\n        points.forEach(function (p, i) {\n            currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;\n            u.push(currU);\n\n            prevU = currU;\n            prevP = p;\n        });\n        u = u.map(function (x) {\n            return x / prevU;\n        });\n\n        return u;\n    };\n\n    /**\r\n     * Find the maximum squared distance of digitized points to fitted curve.\r\n     *\r\n     * @param {Array<Array<Number>>} points - Array of digitized points\r\n     * @param {Array<Array<Number>>} bez - Fitted curve\r\n     * @param {Array<Number>} parameters - Parameterization of points\r\n     * @returns {Array<Number>} Maximum error (squared) and point of max error\r\n     */\n    function computeMaxError(points, bez, parameters) {\n        var dist, //Current error\n        maxDist, //Maximum error\n        splitPoint, //Point of maximum error\n        v, //Vector from point to curve\n        i, count, point, t;\n\n        maxDist = 0;\n        splitPoint = points.length / 2;\n\n        var t_distMap = mapTtoRelativeDistances(bez, 10);\n\n        for (i = 0, count = points.length; i < count; i++) {\n            point = points[i];\n            //Find 't' for a point on the bez curve that's as close to 'point' as possible:\n            t = find_t(bez, parameters[i], t_distMap, 10);\n\n            v = maths.subtract(bezier.q(bez, t), point);\n            dist = v[0] * v[0] + v[1] * v[1];\n\n            if (dist > maxDist) {\n                maxDist = dist;\n                splitPoint = i;\n            }\n        }\n\n        return [maxDist, splitPoint];\n    };\n\n    //Sample 't's and map them to relative distances along the curve:\n    var mapTtoRelativeDistances = function mapTtoRelativeDistances(bez, B_parts) {\n        var B_t_curr;\n        var B_t_dist = [0];\n        var B_t_prev = bez[0];\n        var sumLen = 0;\n\n        for (var i = 1; i <= B_parts; i++) {\n            B_t_curr = bezier.q(bez, i / B_parts);\n\n            sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));\n\n            B_t_dist.push(sumLen);\n            B_t_prev = B_t_curr;\n        }\n\n        //Normalize B_length to the same interval as the parameter distances; 0 to 1:\n        B_t_dist = B_t_dist.map(function (x) {\n            return x / sumLen;\n        });\n        return B_t_dist;\n    };\n\n    function find_t(bez, param, t_distMap, B_parts) {\n        if (param < 0) {\n            return 0;\n        }\n        if (param > 1) {\n            return 1;\n        }\n\n        /*\r\n            'param' is a value between 0 and 1 telling us the relative position\r\n            of a point on the source polyline (linearly from the start (0) to the end (1)).\r\n            To see if a given curve - 'bez' - is a close approximation of the polyline,\r\n            we compare such a poly-point to the point on the curve that's the same\r\n            relative distance along the curve's length.\r\n              But finding that curve-point takes a little work:\r\n            There is a function \"B(t)\" to find points along a curve from the parametric parameter 't'\r\n            (also relative from 0 to 1: http://stackoverflow.com/a/32841764/1869660\r\n                                        http://pomax.github.io/bezierinfo/#explanation),\r\n            but 't' isn't linear by length (http://gamedev.stackexchange.com/questions/105230).\r\n              So, we sample some points along the curve using a handful of values for 't'.\r\n            Then, we calculate the length between those samples via plain euclidean distance;\r\n            B(t) concentrates the points around sharp turns, so this should give us a good-enough outline of the curve.\r\n            Thus, for a given relative distance ('param'), we can now find an upper and lower value\r\n            for the corresponding 't' by searching through those sampled distances.\r\n            Finally, we just use linear interpolation to find a better value for the exact 't'.\r\n              More info:\r\n                http://gamedev.stackexchange.com/questions/105230/points-evenly-spaced-along-a-bezier-curve\r\n                http://stackoverflow.com/questions/29438398/cheap-way-of-calculating-cubic-bezier-length\r\n                http://steve.hollasch.net/cgindex/curves/cbezarclen.html\r\n                https://github.com/retuxx/tinyspline\r\n        */\n        var lenMax, lenMin, tMax, tMin, t;\n\n        //Find the two t-s that the current param distance lies between,\n        //and then interpolate a somewhat accurate value for the exact t:\n        for (var i = 1; i <= B_parts; i++) {\n\n            if (param <= t_distMap[i]) {\n                tMin = (i - 1) / B_parts;\n                tMax = i / B_parts;\n                lenMin = t_distMap[i - 1];\n                lenMax = t_distMap[i];\n\n                t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;\n                break;\n            }\n        }\n        return t;\n    }\n\n    /**\r\n     * Creates a vector of length 1 which shows the direction from B to A\r\n     */\n    function createTangent(pointA, pointB) {\n        return maths.normalize(maths.subtract(pointA, pointB));\n    }\n\n    /*\r\n        Simplified versions of what we need from math.js\r\n        Optimized for our input, which is only numbers and 1x2 arrays (i.e. [x, y] coordinates).\r\n    */\n\n    var maths = function () {\n        function maths() {\n            _classCallCheck(this, maths);\n        }\n\n        maths.zeros_Xx2x2 = function zeros_Xx2x2(x) {\n            var zs = [];\n            while (x--) {\n                zs.push([0, 0]);\n            }\n            return zs;\n        };\n\n        maths.mulItems = function mulItems(items, multiplier) {\n            //return items.map(x => x*multiplier);\n            return [items[0] * multiplier, items[1] * multiplier];\n        };\n\n        maths.mulMatrix = function mulMatrix(m1, m2) {\n            //https://en.wikipedia.org/wiki/Matrix_multiplication#Matrix_product_.28two_matrices.29\n            //Simplified to only handle 1-dimensional matrices (i.e. arrays) of equal length:\n            //  return m1.reduce((sum,x1,i) => sum + (x1*m2[i]),\n            //                   0);\n            return m1[0] * m2[0] + m1[1] * m2[1];\n        };\n\n        maths.subtract = function subtract(arr1, arr2) {\n            //return arr1.map((x1, i) => x1 - arr2[i]);\n            return [arr1[0] - arr2[0], arr1[1] - arr2[1]];\n        };\n\n        maths.addArrays = function addArrays(arr1, arr2) {\n            //return arr1.map((x1, i) => x1 + arr2[i]);\n            return [arr1[0] + arr2[0], arr1[1] + arr2[1]];\n        };\n\n        maths.addItems = function addItems(items, addition) {\n            //return items.map(x => x+addition);\n            return [items[0] + addition, items[1] + addition];\n        };\n\n        maths.sum = function sum(items) {\n            return items.reduce(function (sum, x) {\n                return sum + x;\n            });\n        };\n\n        maths.dot = function dot(m1, m2) {\n            return maths.mulMatrix(m1, m2);\n        };\n\n        maths.vectorLen = function vectorLen(v) {\n            var a = v[0],\n                b = v[1];\n            return Math.sqrt(a * a + b * b);\n        };\n\n        maths.divItems = function divItems(items, divisor) {\n            //return items.map(x => x/divisor);\n            return [items[0] / divisor, items[1] / divisor];\n        };\n\n        maths.squareItems = function squareItems(items) {\n            //return items.map(x => x*x);\n            var a = items[0],\n                b = items[1];\n            return [a * a, b * b];\n        };\n\n        maths.normalize = function normalize(v) {\n            return this.divItems(v, this.vectorLen(v));\n        };\n\n        return maths;\n    }();\n\n    var bezier = function () {\n        function bezier() {\n            _classCallCheck(this, bezier);\n        }\n\n        bezier.q = function q(ctrlPoly, t) {\n            var tx = 1.0 - t;\n            var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx),\n                pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t),\n                pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t),\n                pD = maths.mulItems(ctrlPoly[3], t * t * t);\n            return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));\n        };\n\n        bezier.qprime = function qprime(ctrlPoly, t) {\n            var tx = 1.0 - t;\n            var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx),\n                pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t),\n                pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);\n            return maths.addArrays(maths.addArrays(pA, pB), pC);\n        };\n\n        bezier.qprimeprime = function qprimeprime(ctrlPoly, t) {\n            return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1.0 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));\n        };\n\n        return bezier;\n    }();\n\n    module.exports = fitCurve;\n});\n","import Curve from 'fit-curve'\n\nimport { bezierCurveTo } from './bezierCurveTo'\n\n/**\n * Calculate points for smooth bezier curves passing through a series of points\n * uses https://github.com/soswow/fit-curve/blob/master/src/fit-curve.js\n * uses ShapePoints.curveError=50 for error value\n * @module shape-points/bezierCurveThrough\n * @param {(number|number[])} x1 - starting point or array of points [x1, y1, x2, y2, ... xn, yn]\n * @param {number} [y1]\n * @param {number} [x2]\n * @param {number} [y2]\n * @param {number} [xn] - ending point\n * @param {number} [yn]\n * @param {object} [options]\n * @param {number} [options.pointsInArc=5]\n * @param {number} [options.curveError=50]\n * @returns {number[]} [x1, y1, x2, y2, ... xn, yn]\n */\nexport function bezierCurveThrough()\n{\n    let pointsInArc = 5, curveError = 50\n    const points = []\n    if (Array.isArray(arguments[0]))\n    {\n        const array = arguments[0]\n        for (let i = 0; i < array.length; i += 2)\n        {\n            points.push([array[i], array[i + 1]])\n        }\n        if (arguments.length === 2)\n        {\n            pointsInArc = arguments[1].pointsInArc\n            curveError = arguments[1].curveError\n        }\n    }\n    else\n    {\n        let length = arguments.length\n        if (arguments.length % 2 === 1)\n        {\n            length--\n            pointsInArc = arguments[length].pointsInArc\n            curveError = arguments[length].curveError\n        }\n        for (let i = 0; i < length; i += 2)\n        {\n            points.push([arguments[i], arguments[i + 1]])\n        }\n    }\n\n    // two points creates a line\n    if (points.length === 2)\n    {\n        return [points[0][0], points[0][1], points[1][0], points[1][1]]\n    }\n\n    // not enough points\n    if (points.length < 4)\n    {\n        return []\n    }\n\n    const results = []\n    const curves = Curve(points, curveError)\n    for (let i = 0; i < curves.length; i++)\n    {\n        const c = curves[i]\n        results.push(...bezierCurveTo(c[0][0], c[0][1], c[1][0], c[1][1], c[2][0], c[2][1], c[3][0], c[3][1], pointsInArc))\n    }\n    return results\n}","/**\n * calculate points for a circle (calculates using pointsInArc * 4)\n * @module shape-points/circle\n * @param {number} x\n * @param {number} y\n * @param {number} radius\n * @param {number} [pointsInArc=5]\n * @returns {array} [x1, y1, x2, y2, ... xn, yn]\n */\nexport function circle(x, y, radius, pointsInArc)\n{\n    pointsInArc = pointsInArc || 5\n    const points = []\n    const interval = Math.PI * 2 / (pointsInArc * 4)\n    for (let i = 0; i < Math.PI * 2; i += interval)\n    {\n        points.push(x + Math.cos(i) * radius, y + Math.sin(i) * radius)\n    }\n    return points\n}","/**\n * calculate points for a ellipse (calculates using pointsInArc * 4)\n * @module shape-points/ellipse\n * @param {number} x\n * @param {number} y\n * @param {number} rx\n * @param {number} ry\n * @param {number} [pointsInArc=5]\n * @returns {array} [x1, y1, x2, y2, ... xn, yn]\n */\nexport function ellipse(x, y, rx, ry, pointsInArc)\n{\n    pointsInArc = pointsInArc || 5\n    const points = []\n    const interval = Math.PI * 2 / (pointsInArc * 4)\n    for (let i = 0; i < Math.PI * 2; i += interval)\n    {\n        points.push(x - rx * Math.sin(i), y - ry * Math.cos(i))\n    }\n    return points\n}\n\n","/**\n * calculate points for a line with a certain thickness (either one thickness or a starting and ending thickness)\n * @module shape-points/line\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number|object} [thickness]\n * @param {number} thickness.start\n * @param {number} thickness.end\n * @returns {array} [x1, y1, x2, y2, ... xn, yn]\n */\nexport function line(x1, y1, x2, y2, thickness)\n{\n    thickness = thickness || 0\n    const angle = Math.atan2(y2 - y1, x2 - x1)\n    const perp = angle - Math.PI / 2\n    const half = isNaN(thickness) ? { start: thickness.start / 2, end: thickness.end / 2 } : { start: thickness / 2, end: thickness / 2 }\n    return [\n        x1 - Math.cos(perp) * half.start, y1 - Math.sin(perp) * half.start,\n        x2 - Math.cos(perp) * half.end, y2 - Math.sin(perp) * half.end,\n        x2 + Math.cos(perp) * half.end, y2 + Math.sin(perp) * half.end,\n        x1 + Math.cos(perp) * half.start, y1 + Math.sin(perp) * half.start\n    ]\n}\n\n","/**\n * calculate points in a quadratic curve\n * @module shape-points/quadraticCurveTo\n * @param {number} x1 - starting point\n * @param {number} y1\n * @param {number} cp1x - control point\n * @param {number} cp1y\n * @param {number} x2 - ending point\n * @param {number} y2\n * @returns {array} [x1, y1, x2, y2, ... xn, yn]\n */\nexport function quadraticCurveTo(x1, y1, cp1x, cp1y, x2, y2, pointsInArc)\n{\n    pointsInArc = pointsInArc || 5\n    const points = []\n    const interval = 1 / pointsInArc\n    for (let t = 0; t <= 1; t += interval)\n    {\n        const B0_t = Math.pow(1 - t, 2),\n            B1_t = 2 * t * (1 - t),\n            B2_t = Math.pow(t, 2)\n\n        points.push(\n            (B0_t * x1) + (B1_t * cp1x) + (B2_t * x2),\n            (B0_t * y1) + (B1_t * cp1y) + (B2_t * y2)\n        )\n    }\n    return points\n}","/**\n * calculate points for rectangle\n * @module shape-points/rect\n * @param {number} x (center)\n * @param {number} y\n * @param {number} width\n * @param {number} height\n * @returns {array} [x1, y1, x2, y2, ... xn, yn]\n */\nexport function rect(x, y, width, height)\n{\n    return [\n        x - width / 2, y - height / 2,\n        x + width / 2, y - height / 2,\n        x + width / 2, y + height / 2,\n        x - width / 2, y + height / 2\n    ]\n}","import { arc } from './arc'\n\n/**\n * calculate points for a rounded rectangle with one corner radius, or 4 separate corner radii\n * @module shape-points/roundedRect\n * @param {number} x (center)\n * @param {number} y\n * @param {number} width\n * @param {number} height\n * @param {(number|object)} radius\n * @param {number} [radius.topLeft]\n * @param {number} [radius.topRight]\n * @param {number} [radius.bottomLeft]\n * @param {number} [radius.bottomRight]\n * @param {number} [pointsInArc=5]\n * @returns {array} [x1, y1, x2, y2, ... xn, yn]\n */\nexport function roundedRect(x, y, width, height, radius, pointsInArc)\n{\n    pointsInArc = pointsInArc || 5\n    if (isNaN(radius))\n    {\n        radius.topLeft = radius.topLeft || 0\n        radius.topRight = radius.topRight || 0\n        radius.bottomLeft = radius.bottomLeft || 0\n        radius.bottomRight = radius.bottomRight || 0\n        const points = [\n            x - width / 2 + radius.topLeft, y - height / 2,\n            x + width / 2 - radius.topRight, y - height / 2\n        ]\n        if (radius.topRight)\n        {\n            points.push(...arc(x + width / 2 - radius.topRight, y - height / 2 + radius.topRight, 3 * Math.PI / 2, Math.PI * 2, radius.topRight, pointsInArc))\n        }\n        points.push(\n            x + width / 2, y - height / 2 + radius.topRight,\n            x + width / 2, y + height / 2 - radius.bottomRight\n        )\n        if (radius.bottomRight)\n        {\n            points.push(...arc(x + width / 2 - radius.bottomRight, y + height / 2 - radius.bottomRight, 0, Math.PI / 2, radius.bottomRight, pointsInArc))\n        }\n        points.push(\n            x + width / 2 - radius.bottomRight, y + height / 2,\n            x - width / 2 + radius.bottomLeft, y + height / 2\n        )\n        if (radius.bottomLeft)\n        {\n            points.push(...arc(x - width / 2 + radius.bottomLeft, y + height / 2 - radius.bottomLeft, Math.PI / 2, Math.PI, radius.bottomLeft, pointsInArc))\n        }\n        points.push(\n            x - width / 2, y + height / 2 - radius.bottomLeft,\n            x - width / 2, y - height / 2 + radius.topLeft\n        )\n        if (radius.topLeft)\n        {\n            points.push(...arc(x - width / 2 + radius.topLeft, y - height / 2 + radius.topLeft, Math.PI, 3 * Math.PI / 2, radius.topLeft, pointsInArc))\n        }\n        return points\n    }\n    return [\n        x - width / 2 + radius, y - height / 2,\n        x + width / 2 - radius, y - height / 2,\n        ...arc(x + width / 2 - radius, y - height / 2 + radius, 3 * Math.PI / 2, 2 * Math.PI, radius, pointsInArc),\n        x + width / 2, y - height / 2 + radius,\n        x + width / 2, y + height / 2 - radius,\n        ...arc(x + width / 2 - radius, y + height / 2 - radius, 0, Math.PI / 2, radius, pointsInArc),\n        x + width / 2 - radius, y + height / 2,\n        x - width / 2 + radius, y + height / 2,\n        ...arc(x - width / 2 + radius, y + height / 2 - radius, Math.PI / 2, Math.PI, radius, pointsInArc),\n        x - width / 2, y + height / 2 - radius,\n        x - width / 2, y - height / 2 + radius,\n        ...arc(x - width / 2 + radius, y - height / 2 + radius, Math.PI, 3 * Math.PI / 2, radius, pointsInArc),\n    ]\n}"],"names":["arc","x","y","start","end","radius","pointsInArc","points","angle","interval","count","push","Math","cos","sin","bezierCurveTo","x1","y1","cp1x","cp1y","cp2x","cp2y","x2","y2","t","B0_t","pow","B1_t","B2_t","B3_t","module","_classCallCheck","instance","Constructor","TypeError","generateAndReport","paramsOrig","paramsPrime","leftTangent","rightTangent","progressCallback","bezCurve","maxError","splitPoint","_computeMaxError","bez","parameters","dist","maxDist","v","i","point","length","t_distMap","mapTtoRelativeDistances","find_t","maths","subtract","bezier","q","computeMaxError","A","a","C","X","det_C0_C1","det_C0_X","det_X_C1","alpha_l","alpha_r","epsilon","segLength","len","tmp","u","ux","firstPoint","lastPoint","zeros_Xx2x2","mulItems","dot","vectorLen","addArrays","generateBezier","params","maxErr","maxPoint","reparameterize","map","p","newtonRaphsonRootFind","d","qprime","numerator","mulMatrix","denominator","sum","addItems","squareItems","qprimeprime","B_parts","B_t_curr","B_t_dist","B_t_prev","sumLen","param","lenMin","tMax","tMin","createTangent","pointA","pointB","normalize","this","zs","items","multiplier","m1","m2","arr1","arr2","addition","reduce","b","sqrt","divItems","divisor","ctrlPoly","tx","pA","pB","pC","pD","exports","Array","isArray","forEach","Error","filter","fitCubic","error","uPrime","prevErr","prevSplit","centerVector","toCenterTangent","fromCenterTangent","beziers","currU","prevU","prevP","chordLengthParameterize","_generateAndReport","_generateAndReport2","errChange","reverse","concat","slice","factory","curveError","arguments","array","results","curves","Curve","c","PI","rx","ry","thickness","perp","atan2","half","isNaN","width","height","topLeft","topRight","bottomLeft","bottomRight"],"mappings":"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"}